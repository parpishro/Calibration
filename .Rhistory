s <- set_hyperPriors(alphaS = list(dist = "fixed", init = 2))
s <- set_hyperPriors(alphaS = list(dist = "fixed", init = 2, p1 = 1, p2 = 1))
cal1 <- calibrate(sim=Ds1, field = Df1, Nmcmc=10, nBurn=0, thinning = 1, hypers = s)
cal1$estimates
load_all()
s <- set_hyperPriors(alphaSDist = "fixed", alphaSInit = 2))
s <- set_hyperPriors(alphaSDist = "fixed", alphaSInit = 2)
cal1 <- calibrate(sim=Ds1, field = Df1, Nmcmc=10, nBurn=0, thinning = 1, hypers = s)
load_all()
library(testthat)
# This file is part of the standard setup for testthat.
# It is recommended that you do not modify it.
#
# Where should you do additional test configuration?
# Learn more about the roles of various files in:
# * https://r-pkgs.org/tests.html
# * https://testthat.r-lib.org/reference/test_package.html#special-files
library(testthat)
library(FBC)
test_check("FBC")
load_all()
k <- c(2, 2, 2, 2, 2, 2, 2)
sd(k)
cal1$estimates
load_all()
cal1$acceptance
load_all()
cal <- calibrate(sim = Ds2, field = Df2, Nmcmc = 15, nBurn = 0, thinning = 1,
kappa = list(dist = c("beta", "uniform"),
init = c(0.5, 0.3),
p1   = c(1.1, 0),
p2   = c(1.1, 1)))
cal <- calibrate(sim = Ds2, field = Df2, Nmcmc = 15, nBurn = 0, thinning = 1,
kappa = list(dist = c("beta", "uniform"),
init = c(0.5, 0.3),
p1   = c(1.1, 0),
p2   = c(1.1, 1)))
load_all()
cal <- calibrate(sim = Ds2, field = Df2, Nmcmc = 15, nBurn = 0, thinning = 1,
kappa = list(dist = c("beta", "uniform"),
init = c(0.5, 0.3),
p1   = c(1.1, 0),
p2   = c(1.1, 1)))
plot(cal)
cal <- calibrate(sim = Ds2, field = Df2, Nmcmc = 15, nBurn = 0, thinning = 1,
kappa = list(dist = c("beta", "uniform"),
init = c(0.5, 0.3),
p1   = c(1.1, 0),
p2   = c(1.1, 1)))
cal$estimates
load_all()
priorFns         <- c(priorFns, prior_builder(prior =  dist[j], p1 = p1[j], p2 = p2[j]))
library(FBC)
replicate(2, prior_builder("uniform", p1 = 0, p2 = 1)
f <- replicate(2, prior_builder("uniform", p1 = 0, p2 = 1)
f <- replicate(2, prior_builder("uniform", p1 = 0, p2 = 1))
f[1](0.5)
f[[1]](0.5)
f[[1]](1)
f[[1]](12)
f <- prior_builder("uniform", p1 = 0, p2 = 1)
f(0.5)
exp(f(0.5))
exp(f(0.75))
exp(f(1.75))
library(devtools)
library(FBC)
kappa = list(dist = c("beta", "uniform"),
cal <- calibrate(sim = Ds2, field = Df2, Nmcmc = 15, nBurn = 0, thinning = 1,
kappa = list(dist = c("beta", "uniform"),
init = c(0.5, 0.3),
p1   = c(1.1, 0),
p2   = c(1.1, 1)))
plot(cal)
l <- c(1.1, 4)
l[1]
l[[1]]
pr  <- set_hyperPriors(alphaSDist = "fixed", alphaSInit = 2)
cal <- calibrate(sim = Ds1, field = Df1, Nmcmc = 10, nBurn = 0, thinning = 1, hypers = pr)
load_all()
cal <- calibrate(sim = Ds1, field = Df1, Nmcmc = 10, nBurn = 0, thinning = 1, hypers = pr)
load_all()
cal <- calibrate(sim = Ds1, field = Df1, Nmcmc = 10, nBurn = 0, thinning = 1, hypers = pr)
load_all()
cal <- calibrate(sim = Ds1, field = Df1, Nmcmc = 10, nBurn = 0, thinning = 1, hypers = pr)
load_all()
cal <- calibrate(sim = Ds1, field = Df1, Nmcmc = 10, nBurn = 0, thinning = 1, hypers = pr)
load_all()
cal <- calibrate(sim = Ds1, field = Df1, Nmcmc = 10, nBurn = 0, thinning = 1, hypers = pr)
load_all()
cal <- calibrate(sim = Ds1, field = Df1, Nmcmc = 10, nBurn = 0, thinning = 1, hypers = pr)
load_all()
cal <- calibrate(sim = Ds1, field = Df1, Nmcmc = 10, nBurn = 0, thinning = 1, hypers = pr)
load_all()
cal <- calibrate(sim = Ds1, field = Df1, Nmcmc = 10, nBurn = 0, thinning = 1, hypers = pr)
load_all()
cal <- calibrate(sim = Ds1, field = Df1, Nmcmc = 50, nBurn = 0, thinning = 1)
load_all()
cal <- calibrate(sim = Ds1, field = Df1, Nmcmc = 50, nBurn = 0, thinning = 1)
# build a simple calibration model
cal1    <- calibrate(sim = Ds1, field = Df1,
Nmcmc = 5, nBurn = 0, thinning = 1,
kappa = list(dist = "gaussian", init = 0.5, p1 = 0.5, p2 = 0.25))
preds <- predict(cal1, newdata = matrix(Df1[,2], ncol = 1))
preds$pred
cal2   <- calibrate(sim = Ds2, field = Df2, Nmcmc = 10, nBurn = 0, thinning = 1)
predsB <- predict(cal2, newdata = Df2[, 2:3], type = "Bayesian")
predsB$pred
predsB$se
predsM <- predict(cal2, newdata = Df2[, 2:3], type = "MAP")
predsM$pred
predsM$se
pr1   <- set_hyperPriors(sigma2SDist = "jeffreys")
cal1  <- calibrate(sim = Ds1, field = Df1,
Nmcmc = 5, nBurn = 0, thinning = 1,
hypers = pr1)
cal$estimates
pr2   <- set_hyperPriors(alphaSDist = c("gamma", "beta"),
alphaSP1 = c(1, 2),
alphaBP2 = c(2, 4))
traceback()
load_all()
pr2   <- set_hyperPriors(alphaSDist = c("gamma", "beta"),
alphaSP1 = c(1, 2),
alphaBP2 = c(2, 4))
pr2   <- set_hyperPriors(alphaSDist = c("gamma", "beta"),
alphaSP1 = c(1, 2),
alphaBP2 = c(2, 4))
load_all()
pr2   <- set_hyperPriors(alphaSDist = c("gamma", "beta"),
alphaSP1 = c(1, 2),
alphaBP2 = c(2, 4))
c("gamma", "beta") %in% c("uniform", "gaussian", "gamma", "beta", "lognormal", "logistic",
"betashift", "exponential", "inversegamma", "jeffreys", "fixed")
!(c("gamma", "beta") %in% c("uniform", "gaussian", "gamma", "beta", "lognormal", "logistic",
"betashift", "exponential", "inversegamma", "jeffreys", "fixed"))
sum(!(c("gamma", "beta") %in% c("uniform", "gaussian", "gamma", "beta", "lognormal", "logistic",
"betashift", "exponential", "inversegamma", "jeffreys", "fixed")))
is.double(c(1, 2))
load_all()
pr2   <- set_hyperPriors(alphaSDist = c("gamma", "beta"),
alphaSP1 = c(1, 2),
alphaBP2 = c(2, 4))
pr2   <- set_hyperPriors(alphaSDist = c("gamma", "beta"),
alphaSP1 = c(1, 2),
alphaSP2 = c(2, 4))
cal2  <- calibrate(sim = Ds1, field = Df1,
Nmcmc = 5, nBurn = 0, thinning = 1,
hypers = pr2)
load_all()
document()
load_all()
document()
load_all()
document()
load_all()
document()
load_all()
document()
load_all()
document()
load_all()
use_vignette("fbc")
load_all()
usethis::use_github_action_check_standard()
use_github_actions_badge(name = "R-CMD-check.yaml", repo_spec = NULL)
use_github_action_check_standard()
add_github_actions_codecov()
install.packages("rcompendium")
library(rcompendium)
add_github_actions_codecov()
add_codecov_badge()
add_cran_badge()
add_dependencies_badge()
, add_github_actions_check_badge()
add_github_actions_check_badge()
add_github_actions_pkgdown_badge()
add_license_badge()
add_lifecycle_badge()
add_repostatus_badge()
use_coverage(pkg = ".", type = c("codecov"))
library(devtools)
use_coverage(type = c("codecov"))
---
title: "FBC: Full Bayesian Calibration"
knitr::opts_chunk$set(
collapse = TRUE,
comment = ">"
)
options(width = 100)
library(FBC)
head(ballField, 3)
dim(ballField)
head(ballSim, 3)
dim(ballSim)
plot(ballField[, 2], ballField[, 1], cex = 0.65, pch = 19, col = "red", ylim = c(0, 1.5),
xlab="Height (m)", ylab="Time (s)")
points(ballSim[, 2], ballSim[, 1], cex = 0.65, pch = 19, col = "blue")
legend("topleft", legend = c("Simulation", "Field"),
col = c("blue", "red"), pch = 16, cex = 0.8)
library(devtools)
load_all()
output <- calibrate(sim = ballSim, field = ballField,                                 # Data
Nmcmc = 11000, nBurn = 1000, thinning = 50,                       # MCMC
kappaDist = "beta", kappaInit = NA, kappaP1 = 1.1, kappaP2 = 1.1, # Priors
hypers = set_hyperPriors(),
showProgress = FALSE)
save(output, "/inst/output.rda")
save(output, file="/inst/output.rda")
save(output, file="inst/output.rda")
load(".../inst/output.rda")
load("inst/output.rda")
output_path <- system.file("output.rda", package = "FBC")
load(output_path)
output_path <- system.file("output.rda", package = "FBC")
load(output_path)
names(output)
knitr::opts_chunk$set(
collapse = TRUE,
comment = ">"
)
library(FBC)
head(ballField, 3)
dim(ballField)
head(ballSim, 3)
dim(ballSim)
plot(ballField[, 2], ballField[, 1], cex = 0.65, pch = 19, col = "red", ylim = c(0, 1.5),
xlab = "Height (m)", ylab = "Time (s)")
points(ballSim[, 2], ballSim[, 1], cex = 0.65, pch = 19, col = "blue")
legend("topleft", legend = c("Simulation", "Field"),
col = c("blue", "red"), pch = 16, cex = 0.8)
title(main = "Figure 1: Ball Drop Experiments", adj = 0)
priors <- set_hyperPriors(thetaSDist = "beta", thetaBP2 = 6)
output_path <- system.file("output.rda", package = "FBC")
load(output_path)
load_all()
output_path <- system.file("output.rda", package = "FBC", mustWork = TRUE)
load(output_path)
library(FBC)
vignette("FBC")
vignette("fbc")
vignette("fbc", package = "FBC")
library(FBC)
vignette("fbc", package = "FBC")
vignette("fbc.rmd", package = "FBC")
load_all()
vignette("fbc", package = "FBC")
vignetteInfo(package = "FBC")
vignette("fbc", package = "FBC")
knitr::knit("vignettes/fbc.Rmd")
load_all()
vignette("fbc", package = "FBC")
library(usethis)
library(devtools)
load_all()
use_vignette("fbc-vignette")
load_all()
install()
vignette("fbc")
library(FBC)
library("FBC")
vignette("FBC")
library(rmarkdown)
document()
vignette(fbc)
vignette("fbc")
load_all()
library(FBC)
vignette("fbc")
vignetteInfo(package = "FBC")
predsMAP <- predict(object = output, newdata = matrix(c(2.2, 2.4), ncol = 1), method = "MAP")
predsMAP
predsBayes <- predict(object = output, newdata = matrix(c(2.2, 2.4), ncol = 1), method = "Bayesian")
predsBayes
predsMAP
predsBayes
load_all()
check()
library(usethis)
library(devtools)
load_all()
use_gpl_license()
use_mit_license(copyright_holder = "Parham Pishrobat")
use_gpl_license(version = 2)
?calibrate
load_all()
document()
install()
library(testthat)
# This file is part of the standard setup for testthat.
# It is recommended that you do not modify it.
#
# Where should you do additional test configuration?
# Learn more about the roles of various files in:
# * https://r-pkgs.org/tests.html
# * https://testthat.r-lib.org/reference/test_package.html#special-files
library(testthat)
library(FBC)
test_check("FBC")
use_testthat()
test()
load_all()
check()
library(FBC)
check()
use_devtools()
dev_sitrep()
update_packages("devtools")
update_packages("FBC")
install_dev_deps()
dev_sitrep()
.libPaths()
lapply(.libPaths(), list.dirs, recursive = FALSE, full.names = FALSE)
R_LIBS_USER
Sys.getenv("R_LIBS_USER")
F2
proj_sitrep()
X     <- matrix(c(1, 3, 5,
2, 2, 6,
1, 4, 1), nrow = 3, byrow = TRUE)
Y     <- matrix(c(7, 3, 0,
2, 2, 4), nrow = 2, byrow = TRUE)
sc    <- c(1, 2, 3) # scale parameters of correlation structure
sm    <- c(2, 1, 2) # smoothness parameters of correlation structure
# correlation of a matrix with itself
correlation(X, theta = sc, alpha = sm)
summary(output)
print(output)
summary(output) # print(output) has exactly the same output
par()
par(mfrow)
knitr::opts_chunk$set(
collapse = TRUE,
comment = ">"
)
options(width = 100)
library(FBC)
head(ballField, 3)
dim(ballField)
head(ballSim, 3)
dim(ballSim)
plot(ballField[, 2], ballField[, 1], cex = 0.65, pch = 19, col = "red", ylim = c(0, 1.5),
xlab = "Height (m)", ylab = "Time (s)")
points(ballSim[, 2], ballSim[, 1], cex = 0.65, pch = 19, col = "blue")
legend("topleft", legend = c("Simulation", "Field"),
col = c("blue", "red"), pch = 16, cex = 0.8)
title(main = "Figure 1: Ball Drop Experiments", adj = 0)
output_path <- system.file("output.rda", package = "FBC", mustWork = TRUE)
load(output_path)
names(output)
head(output$Phi, 3)
predsMAP   <- predict(object = output, newdata = matrix(c(2.2, 2.4), ncol = 1), method = "MAP")
predsBayes <- predict(object = output, newdata = matrix(c(2.2, 2.4), ncol = 1), method = "Bayesian")
predsMAP
predsBayes
priors <- set_hyperPriors(thetaSDist = "beta", thetaBP2 = 6)
summary(output) # print(output) has exactly the same output
# plot other model parameters (note that since there are two correlation scale parameters for
# simulator GP, there will be two plots)
plot(output, parameter = "thetaS")
# plot the trace of MCMC draws (note that this plot is useful to determine convergence and
# stationarity of the parameter draws. This minimal example dhas only few draws!)
plot(output, parameter = "alphaS", type = "trace")
# plot the fitted values of the calibration model. It will plot the fitted values versus all
# experimental inputs, in this example only one!
plot(output, type = "fits")
# plot the fitted values of the calibration model. It will plot the fitted values versus all
# experimental inputs, in this example only one!
plot(output, type = "fits", xlab = "height")
length("height")
library(devtools)
load_all()
knitr::opts_chunk$set(
collapse = TRUE,
comment = ">"
)
options(width = 100)
library(FBC)
head(ballField, 3)
dim(ballField)
head(ballSim, 3)
dim(ballSim)
plot(ballField[, 2], ballField[, 1], cex = 0.65, pch = 19, col = "red", ylim = c(0, 1.5),
xlab = "Height (m)", ylab = "Time (s)")
points(ballSim[, 2], ballSim[, 1], cex = 0.65, pch = 19, col = "blue")
legend("topleft", legend = c("Simulation", "Field"),
col = c("blue", "red"), pch = 16, cex = 0.8)
title(main = "Figure 1: Ball Drop Experiments", adj = 0)
output_path <- system.file("output.rda", package = "FBC", mustWork = TRUE)
load(output_path)
names(output)
head(output$Phi, 3)
predsMAP   <- predict(object = output, newdata = matrix(c(2.2, 2.4), ncol = 1), method = "MAP")
predsBayes <- predict(object = output, newdata = matrix(c(2.2, 2.4), ncol = 1), method = "Bayesian")
predsMAP
predsBayes
priors <- set_hyperPriors(thetaSDist = "beta", thetaBP2 = 6)
summary(output) # print(output) has exactly the same output
# plot other model parameters (note that since there are two correlation scale parameters for
# simulator GP, there will be two plots)
plot(output, parameter = "thetaS")
# plot the trace of MCMC draws (note that this plot is useful to determine convergence and
# stationarity of the parameter draws. This minimal example dhas only few draws!)
plot(output, parameter = "alphaS", type = "trace")
# plot the fitted values of the calibration model. It will plot the fitted values versus all
# experimental inputs, in this example only one!
plot(output, type = "fits", xlab = "height")
X     <- matrix(c(1, 3, 5,
2, 2, 6,
1, 4, 1), nrow = 3, byrow = TRUE)
Y     <- matrix(c(7, 3, 0,
2, 2, 4), nrow = 2, byrow = TRUE)
sc    <- c(1, 2, 3) # scale parameters of correlation structure
sm    <- c(2, 1, 2) # smoothness parameters of correlation structure
# correlation of a matrix with itself
correlation(X, theta = sc, alpha = sm)
# correlation between two matrices
correlation(X, Y, theta = sc, alpha = sm)
X     <- matrix(c(1, 3, 5,
2, 2, 6,
1, 4, 1), nrow = 3, byrow = TRUE)
Y     <- matrix(c(7, 3, 0,
2, 2, 4), nrow = 2, byrow = TRUE)
sc    <- c(1, 2, 3) # scale parameters of correlation structure
sm    <- c(2, 1, 2) # smoothness parameters of correlation structure
# correlation of a matrix with itself
round(correlation(X, theta = sc, alpha = sm), 2)
# correlation between two matrices
round(correlation(X, Y, theta = sc, alpha = sm), 2)
X     <- matrix(c(1, 3, 5,
2, 2, 6,
1, 4, 1), nrow = 3, byrow = TRUE)
Y     <- matrix(c(7, 3, 0,
2, 2, 4), nrow = 2, byrow = TRUE)
sc    <- c(1, 2, 3) # scale parameters of correlation structure
sm    <- c(2, 1, 2) # smoothness parameters of correlation structure
# correlation of a matrix with itself
round(correlation(X, theta = sc, alpha = sm), 4)
# correlation between two matrices
round(correlation(X, Y, theta = sc, alpha = sm), 4)
X     <- matrix(c(1, 3, 5,
2, 2, 6,
1, 4, 1), nrow = 3, byrow = TRUE)
Y     <- matrix(c(7, 3, 0,
2, 2, 4), nrow = 2, byrow = TRUE)
sc    <- c(1, 2, 3) # scale parameters of correlation structure
sm    <- c(2, 1, 2) # smoothness parameters of correlation structure
# correlation of a matrix with itself
round(correlation(X, theta = sc, alpha = sm), 5)
# correlation between two matrices
round(correlation(X, Y, theta = sc, alpha = sm), 5)
# create a prior function for beta(2, 5)
pr_fun <- prior_builder(prior = "beta", p1 = 2, p2 = 5)
pr_fun(c(-1, 0, 0.5, 1, 2))
# create a prior function for beta(2, 5)
pr_fun <- prior_builder(prior = "beta", p1 = 2, p2 = 5)
exp(pr_fun(c(-1, 0, 0.5, 1, 2)))
# create a prior function for beta(2, 5)
pr_fun <- prior_builder(prior = "beta", p1 = 2, p2 = 5)
exp(pr_fun(c(-1, 0, 0.1, 0.5, 0.9, 1, 2)))
# create a prior function for beta(2, 5). Note that the function compute log of priors and must be transformed
pr_fun <- prior_builder(prior = "beta", p1 = 2, p2 = 5)
exp(pr_fun(c(-1, 0, 0.1, 0.5, 0.9, 1, 2)))
# create a prior function for a Uniform distribution with lower bound of -10, and upper bound of 10
pr_fun <- prior_builder(prior = "uniform", p1 = -10, p2 = 10)
exp(pr_fun(c(-11, -5, 0, 4, 10, 12)))
# create a prior function for Gaussian distribution with mean of 1 and standard deviation of 2
pr_fun <- prior_builder(prior = "gaussian", p1 = 1, p2 = 2)
exp(pr_fun(c(-9, -5, -3, -1, 1, 3, 5, 7, 11)))
# create a prior function for beta(2, 5). Note that the function compute log of priors and must be transformed
pr_fun <- prior_builder(prior = "beta", p1 = 2, p2 = 5)
round(exp(pr_fun(c(-1, 0, 0.1, 0.5, 0.9, 1, 2))), 3)
# create a prior function for a Uniform distribution with lower bound of -10, and upper bound of 10
pr_fun <- prior_builder(prior = "uniform", p1 = -10, p2 = 10)
round(exp(pr_fun(c(-11, -5, 0, 4, 10, 12))), 3)
# create a prior function for Gaussian distribution with mean of 1 and standard deviation of 2
pr_fun <- prior_builder(prior = "gaussian", p1 = 1, p2 = 2)
round(exp(pr_fun(c(-9, -5, -3, -1, 1, 3, 5, 7, 11))), 3)
# find the estimated mode of a vector
vec <- runif(100, 0, 10)
pmode(vec)
# find the estimated mode of a vector
vec <- runif(100, 0, 10)
pmode(vec)
pmode(vec, breaks = 20)
# find the estimated mode of a vector
vec <- runif(100, 0, 10)
pmode(vec)
pmode(vec, breaks = 10)
library(FBC)
use_gpl_license()
use_build_ignore("\vignette\vigPDF.aux")
use_build_ignore("vignette\vigPDF.aux")
load_all()
document()
load_all()
document()
library(tools)
file.choose()
use_build_ignore("vignette/vigPDF.aux")
use_build_ignore("vignette/vigPDF.out")
use_build_ignore("vignette/vigPDF.Rmd")
load_all()
document()
use_build_ignore("vignette/vigPDF.pdf")
load_all()
document()
use_build_ignore("LICENSE")
use_build_ignore("inst/vigPDF.Rmd")
load_all()
document()
savehistory("~/Desktop/FBC/.Rhistory.Rhistory")
